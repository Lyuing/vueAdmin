## 需求
### 路由渲染逻辑：
遍历menuList, 检索菜单的code与本地routeList的code一致，筛选出匹配的route进行路由渲染。同时建立一个menuId -> routePath、routeName、menuItem 的映射表，方便后续的快速查询，以及 routeName -> menuItem、routeItem 的映射表，方便后续的快速查询。

### 顶部菜单、侧栏菜单过滤显示：
一级导航显示在顶部栏，子级菜单显示在侧栏。根据显隐判断是否显示，其中导航类型为目录的菜单，根据其是否有子级菜单进行显隐判断（对应的需要修改菜单配置页面的编辑逻辑，若为目录，则不显示显隐）。

### 菜单、面包屑回显：
根据当前页面的路由地址，推断路由的 routeName，再利用前面的映射表推算 menuItem，根据 menuItem 获取它的父级菜单，层层递进，就能获取当前页面的菜单链，再获取对应的path赋值给el-menu进行回显。顶部导航根据菜单链的最顶层进行判断回显。其中要注意隐藏的菜单有一个挂载导航，当回显时，显示它挂载的导航路径。


## 实现
### 概览 — 当前实现要点

- 后端接口返回一棵菜单树（MenuConfig[]），前端把它转换为运行时菜单项 MenuItem[]，并建立多种映射表来支持快速查找与回显（菜单 → 路由、路由名 → 菜单、权限码 → 路由 等）。
- 路由配置保存在 routes（routeMap），路由的 meta 使用 permissionCode 字段与菜单中的 permissionCode 对应，从而把 UI 菜单与路由解耦、通过权限码关联。
- 动态路由通过权限码过滤后添加到路由器；页面刷新时若路由未注册，会尝试根据当前用户/菜单推断并动态注册路由，然后重试导航，保证回显与深链可用。
- 面包屑、顶部导航回显与侧栏回显均通过映射表快速推算，特殊处理“隐藏菜单挂载到某个导航”的场景（隐藏菜单 own.hidden = true 且有 parentMenuCode）以便回显时仍显示对应顶部导航/面包屑链。

### 接口中菜单数据（后端 → 前端）格式

来自后端的菜单项类型定义保存在 navigation.ts（MenuConfig）——关键字段示例：
```
id: string
title: string
icon?: string
permissionCode?: string // 核心：用于关联路由 meta.permissionCode
menuType: 'top'|'sidebar_nav'|'sidebar_directory'
hidden: boolean // 是否隐藏（不在导航直接显示，但可挂载到某导航）
parentMenuCode?: string // 隐藏菜单挂载目标的 permissionCode
children?: MenuConfig[]
```

示例（简化）：
```ts
[
  {
    "id": "1",
    "title": "系统管理",
    "permissionCode": "system",
    "menuType": "top",
    "hidden": false,
    "children": [
      {
        "id": "1-1",
        "title": "用户管理",
        "permissionCode": "system_user",
        "menuType": "sidebar_nav",
        "hidden": false
      },
      {
        "id": "1-2",
        "title": "隐藏功能",
        "permissionCode": "system_secret",
        "menuType": "sidebar_nav",
        "hidden": true,
        "parentMenuCode": "system" 
      }
    ]
  }
]
```

### 菜单如何渲染到路由上（数据流）

1. 启动时（main.ts）：

   - 加载 routeMap（index.ts），并调用 navigationStore.buildPermissionRouteMap(routeMap) 构建 permissionCode -> {path,name} 以及 routeName -> RouteConfig 映射。
  
2. 登录 → 拿到 userInfo.menus：

    - 在 auth.ts 的 login / restoreAuth 中，会调用 navigationStore.loadMenusFromUserInfo(menus)（如果存在）来把后端菜单放入导航 store。

3. navigation.store.setMenus(configs) 流程（主函数，见 navigation.ts）：

    - 过滤/校验原始 MenuConfig[]。
    - 调用 getMenuTree(configs)：把 MenuConfig 转换为 MenuItem，并把 permissionCode 用 permissionRouteMap（前面构建的）映射为 path / routeName，同时计算 breadcrumbPath（初步）。
    - 调用 menuCache.updateCache(menuTree)：构建缓存映射（详见下）。
    - 调用 buildMenuMap(menuTree)：构建 menuMap (id->menu) 和 routeNameMenuMap (routeName->menu) 等，供 UI/面包屑快速访问。

4. 动态路由注册（index.ts 的 addDynamicRoutes）：

   - 接收一个权限码数组 permissions?（通常来自 authStore.userInfo.permissions）。
   - 若未传入权限数组，会从 navigationStore.menuCache.getAllPermissionCodes() 回退获取所有菜单上的权限码（即把菜单驱动的权限码当作可访问范围）。
   - 使用 filterAccessRoutes(routeMap, effectivePermissions)（permissionCode 优先）筛选出应该注册的路由，然后 router.addRoute(...) 添加到 router，并最终加入 /:pathMatch(.*)* -> /404。

### 页面刷新/深链时的回显与路由注册逻辑（守卫）

- 路由守卫位置：guards.ts
    - beforeEach 会处理以下场景：
如果 to.matched.length === 0（当前访问路径在路由表中找不到，常见于刷新或深链）：
若用户未登录 → 跳转 /login。
若已登录且 authStore.userInfo 存在 → 调用 addDynamicRoutes(authStore.userInfo.permissions) 动态注册路由（或让 addDynamicRoutes 从菜单缓存回退获取 permissions），然后执行 next({ ...to, replace: true }) 重新导航一次，趟开新注册的路由。
若仍然找不到 → 跳 /404。
   - 常规需要鉴权的路由会通过 usePermission().checkRoutePermission(to) 校验 permissionCode / permissions / roles。

因此：刷新时若路由未注册，路由守卫会触发动态路由注册（基于用户权限或菜单缓存），注册后重试导航，从而保证页面能被正确渲染并且导航回显能通过 store 的映射表工作。

### 顶部导航 / 侧边导航的回显逻辑

- 主要逻辑在 navigation.ts 和 useNavigation.ts：

    - topMenus：从 navigationStore.getTopMenus() 得到（在 menuTree 中筛选 menuType === 'top' && !hidden）。
    - sidebarMenus：由 navigationStore.getSidebarMenus(route.name) 计算：
        - 首先通过 findTopMenuByRouteName(routeName) 找出当前路由对应的“顶级导航”（即所属顶部菜单）。
        - 返回该顶级菜单的 children（再做 filterVisibleMenus 过滤隐藏项），作为侧栏渲染的数据源。
    - 侧栏选中项（El-Menu 的激活、打开项）：
        - activeMenuIds 来源 navigationStore.findMenuPathByRouteName(route.name)：使用 routeNameMenuMap 找到当前菜单项，然后向上查父级（通过 findParentMenu）构建从根到当前的菜单 ID 列表（用于 default-active 和 default-openeds）。
    - 菜单是否被高亮（顶部菜单是否 active）：
        - isMenuActive(menu, routeName)：直接比较 menu.routeName，递归查找子菜单，或调用 checkMountedHiddenMenus(menu, routeName) 检查挂载到该菜单下的隐藏菜单是否包含该路由（即隐藏菜单挂载也能触发对应顶部导航高亮）。

- 隐藏菜单挂载特性（关键点）：

    - 隐藏菜单 hidden = true 时可能不会在顶部/侧栏直接展示，但它可以设置 parentMenuCode 指向某个可见导航的 permissionCode，用于在回显/面包屑时把隐藏菜单“挂载”在那个导航下。
    - menuCache.hiddenMenuMap 存储 parentPermissionCode -> hiddenMenus[]；checkMountedHiddenMenus 使用该映射判断当前 routeName 是否在挂载的隐藏菜单中。

### 面包屑回显逻辑

- 入口：useNavigation().breadcrumbs（useNavigation.ts）
优先通过 route.name 在 navigationStore.routeNameMenuMap 查找对应菜单项，若没有则通过 menuMap 遍历匹配 path === route.path 作为备用。
返回菜单项的 breadcrumbPath（MenuItem.breadcrumbPath 在 setMenus/updateBreadcrumbPaths 已被预计算并包含挂载关系）。
- generateBreadcrumbPath(menu, allMenus?)（navigation.ts）：
如果菜单是隐藏且存在 parentMenuCode，会先递归获取并合并挂载父菜单的面包屑（即把隐藏菜单的面包屑拼接到挂载的父菜单链上）。
否则按常规父级链（findMenuParentPath）构建父级面包屑，再追加当前菜单本身（包含 path，若无 path 则为 undefined）。
- 因此面包屑能正确显示：常规的按层级显示；隐藏菜单会显示在其挂载的父导航下，从而保证页面刷新或直接访问隐藏路由时，面包屑仍然合理。

### 重要辅助函数 / 缓存（快速索引）

### 路由渲染逻辑：
遍历后端 `menuList`，检索菜单的 `permissionCode` 与本地 `routeMap` 中 route.meta.permissionCode 一致的路由，筛选出匹配的 route 并在运行时注册（动态路由）。同时在前端建立多种映射表以支持快速查询与回显：

- menuId -> MenuItem（id -> menu 对象）
- permissionCode -> { path, name }（用于把菜单映射到路由路径/名称）
- routeName -> MenuItem（routeName -> menu，用于通过路由名回推菜单）
- routeName -> RouteConfig（routeName -> 路由配置，便于查路由元数据）

这些映射由 `src/stores/navigation.ts`（navigation store）和 `src/utils/menu-cache.ts`（MenuCache）负责构建与维护。

    - menuMap: id -> MenuItem
### 顶部菜单、侧栏菜单过滤显示：
一级导航显示在顶部栏，子级菜单显示在侧栏。显示/隐藏由菜单的 `hidden` 字段控制：

- `menuType === 'top' && !hidden` 的项被视为顶部导航源（`getTopMenus()`）。
- 侧栏数据由 `getSidebarMenus(routeName)` 返回：首先通过 `findTopMenuByRouteName(routeName)` 找到当前路由所属的顶级菜单，再返回该顶级菜单的 `children`，并对其做可见性过滤（`filterVisibleMenus`）。

注意：当一个菜单被标记为隐藏（hidden），但设置了 `parentMenuCode` 时，这个隐藏菜单会被“挂载”到 `parentMenuCode` 对应的可见菜单上（用于回显与面包屑）。因此侧栏实际渲染仍只显示可见菜单，但回显逻辑会把挂载的隐藏菜单算作其挂载父的子项，从而在访问隐藏路由时正确回显父导航。
    - routeNameMap: routeName -> MenuItem
    - parentChildMap: parentId -> childId[]
### 菜单、面包屑回显：
根据当前页面的路由地址，推断路由的 `routeName`，再利用映射表推算对应 `MenuItem`，通过父链或挂载关系计算菜单链（从根到可见菜单），并把该菜单链的 ID 列表用于 `el-menu` 的 `default-active` / `default-openeds`，以实现侧栏回显。顶部导航回显由菜单链的最顶层（顶级菜单 `menuType === 'top'`）决定。

面包屑的生成使用 `generateBreadcrumbPath(menu)`：
- 若菜单为隐藏且存在 `parentMenuCode`，先合并挂载父菜单的面包屑，再追加当前隐藏菜单（保持面包屑完整）。
- 否则按结构化父级链（`findMenuParentPath`）生成面包屑。

因此：
- 侧栏只渲染可见菜单（hidden=false），但侧栏激活/展开会在访问隐藏挂载页面时显示其挂载父项为激活项（即“显示为资源管理”而非“资源详情”）。
- 面包屑会显示完整链（包含隐藏详情项）。
    - 提供方法：getMenuById, getMenuByPermissionCode, getMenuByRouteName, getHiddenMenusByParentCode, getAllPermissionCodes() 等

- navigation.store 中新增/关键方法：

    - buildPermissionRouteMap(routes)：把 routeMap 中每个 route 的 meta.permissionCode 映射到 {path, name}，同时记录 routeName -> RouteConfig，用于菜单 -> 路由 映射。
    - getMenuTree(configs)：将后端菜单配置转换为前端 MenuItem（赋 path / routeName / breadcrumbPath / level）。
### 实现
### 概览 — 当前实现要点

后端接口返回一棵菜单树（`MenuConfig[]`），前端把它转换为运行时菜单项 `MenuItem[]`，并由 `navigation store` 与 `MenuCache` 建立与维护以下映射表：

- `menuMap`（id -> MenuItem）
- `permissionRouteMap`（permissionCode -> { path, name }）由 `buildPermissionRouteMap(routeMap)` 构建
- `routeNameMenuMap`（routeName -> MenuItem）
- `routeNameRouteMap`（routeName -> RouteConfig）
- `menuCache.hiddenMenuMap`（parentPermissionCode -> hidden MenuItem[]）用于隐藏菜单的挂载查询

路由注册与回显关键点：

- 路由表 `routeMap` 在应用启动（`main.ts`）时被 `buildPermissionRouteMap` 预处理，建立 `permissionCode -> path/name` 映射，供 `setMenus` 在构建 `MenuItem` 时填充 `path` 与 `routeName`。
- 当用户登录并返回 `userInfo.menus` 时，`navigationStore.loadMenusFromUserInfo(menus)` 会触发 `setMenus(configs)`：
    - 调用 `getMenuTree(configs)` 把后端 `MenuConfig` 转为前端 `MenuItem`（填充 `path`, `routeName`, `breadcrumbPath`, `level`）。
    - 更新 `menuCache`（`menuCache.updateCache(menuTree)`）。
    - 构建 `menuMap`、`routeNameMenuMap` 等映射（`buildMenuMap`）。

- 动态路由注册：`addDynamicRoutes(permissions?)` 接受权限数组（常来源于 `authStore.userInfo.permissions`），若未传入则回退使用 `menuCache.getAllPermissionCodes()`；随后通过 `filterAccessRoutes(routeMap, effectivePermissions)`（优先匹配 `meta.permissionCode`）筛选并 `router.addRoute(...)` 注册可访问路由。

- 路由守卫（`guards.ts`）在 `beforeEach` 中处理刷新/深链场景：若 `to.matched.length === 0` 且已登录，则调用 `addDynamicRoutes(...)` 注册路由后 `next({ ...to, replace: true })` 重试，确保深链可达并触发回显逻辑。

关键方法总结（所在文件）：

- `src/stores/navigation.ts`
    - `buildPermissionRouteMap(routes)`：构建 `permissionRouteMap` 和 `routeNameRouteMap`。
    - `setMenus(configs)` / `getMenuTree(configs)`：把 `MenuConfig` 转为 `MenuItem`，填充 `path`/`routeName`/`breadcrumbPath`。
    - `menuCache.updateCache(menus)`：建立 `menuId`、`permissionCode`、`routeName` 等快速映射以及 `hiddenMenuMap`（挂载映射）。
    - `buildMenuMap(menuTree)`：建立 `menuMap` 与 `routeNameMenuMap`。
    - `findMenuPathByRouteName(routeName)`：给定 routeName 返回从根到目标的菜单 ID 链，函数内部已优化以优先使用隐藏菜单的 `parentMenuCode`（挂载关系）来寻找显示父节点。
    - `findTopMenuByRouteName(routeName)`：向上查找直到 `menuType === 'top'`，优先考虑隐藏菜单的 `parentMenuCode` 挂载链。
    - `findMenuPathByMenuId(menuId)`：返回从根到指定 menuId 的 ID 链（用于挂载父的路径计算）。
    - `isMenuActive`, `checkRouteNameInMenu`, `checkMountedHiddenMenus`：用于确定菜单是否高亮（包含挂载隐藏菜单的判断）。
    - `generateBreadcrumbPath(menu)`：构建面包屑，若菜单为隐藏且有 `parentMenuCode`，会先合并挂载父的面包屑再追加当前项。
    - `resolveMenuPath(menu)`：为菜单点击提供最佳跳转目标（优先 `menu.path`，其次第一个可见子项，再其次挂载的隐藏菜单的 path）。

- `src/utils/menu-cache.ts`（MenuCache）
    - 提供 `getMenuById`, `getMenuByPermissionCode`, `getMenuByRouteName`, `getHiddenMenusByParentCode`, `getAllPermissionCodes()` 等方法。

- `src/composables/useNavigation.ts`
    - 封装 `topMenus`, `sidebarMenus`, `breadcrumbs`, `activeMenuIds` 等组合式计算值。
    - 在 dev 环境下提供调试输出（Active Top Menu / Active Menu IDs / Active Menu Item / Breadcrumbs），并计算 `activeMenuIds` 时：若当前映射到的是隐藏菜单且存在 `parentMenuCode`，会切换为挂载父菜单的 ID 链，以便侧栏高亮显示挂载的可见导航。

- 组件：`TopNav.vue`, `Sidebar.vue`, `MenuItemRenderer.vue` 使用 `navigationStore.resolveMenuPath()` 作为点击跳转的统一入口。
    - findMenuPathByRouteName(routeName)：返回菜单 ID 链（从根到当前），用于侧栏 default-active/default-openeds。
### 重要辅助函数 / 缓存（快速索引）

- `MenuCache`（`src/utils/menu-cache.ts`）维护的映射：

    - `menuMap`: id -> MenuItem
    - `permissionCodeMap`: permissionCode -> MenuItem
    - `routeNameMap`: routeName -> MenuItem
    - `parentChildMap`: parentId -> childId[]
    - `hiddenMenuMap`: parentPermissionCode -> MenuItem[]（用于隐藏菜单挂载）
    - 提供方法：`getMenuById`, `getMenuByPermissionCode`, `getMenuByRouteName`, `getHiddenMenusByParentCode`, `getAllPermissionCodes()` 等
    - navigation.ts ← 主逻辑（映射构建、回显、resolvePath）
### 涉及的主要文件（请 review）

- 核心 store/工具
    - `src/stores/navigation.ts`  ← 主逻辑（映射构建、回显、resolvePath、挂载处理）
    - `src/utils/menu-cache.ts`  ← 缓存和快速查找
    - `src/types/navigation.ts`  ← menu/route 类型定义

- 路由相关
    - `src/router/routes/index.ts` ← 完整 `routeMap`（包含 `meta.permissionCode`）
    - `src/router/index.ts` ← `initRouter`, `addDynamicRoutes`, `resetRouter`
    - `src/router/permission.ts` ← `filterAccessRoutes`（优先使用 `meta.permissionCode`）
    - `src/router/guards.ts` ← 刷新/深链时动态注册路由的守卫逻辑

- 组件使用点
    - `src/composables/useNavigation.ts` ← 组合式封装：`topMenus`, `sidebarMenus`, `breadcrumbs`, `activeMenuIds`
    - `src/components/layout/TopNav.vue`
    - `src/components/layout/Sidebar.vue`
    - `src/components/layout/MenuItemRenderer.vue`

### 已知风险 / 建议测试点

- 风险点：

    - 菜单的 `permissionCode` 必须与 `route.meta.permissionCode` 保持一致，否则菜单与路由无法可靠关联，影响回显和跳转。
    - 若后端返回的某些菜单项缺少 `permissionCode`，`getMenuTree` 将无法为它们填充 `path`/`routeName`，导致点击或回显异常。建议在菜单管理端强制或校验与路由权限码的一致性。
    - `resolveMenuPath` 当前采用深度优先查找第一个可用子路径作为目录的跳转目标；若产品需求是“首子项优先”或另有策略，请告知以调整策略。

- 建议的验收测试：

    - 登录后顶部导航显示正确，点击顶部导航能跳到相应第一个可见子路径（或 `path` 明确指定的跳转目标）。
    - 对于隐藏菜单并设置了 `parentMenuCode` 的场景：直接访问隐藏路由时，顶部导航与侧栏应回显为挂载的父导航（例如访问资源详情时侧栏显示“资源管理”）。
    - 直接刷新深链页面（未先访问主页）能成功加载对应页面且顶部/侧栏及面包屑回显正确。
    - 权限控制测试：无权限的路由不应被注册或应被路由守卫拒绝访问。
    - 检查 `menuCache.getAllPermissionCodes()` 是否返回完整权限集合以满足无权限数组时的路由回退逻辑。

如需，我可以把上述验收点整理成可执行的手动测试脚本或自动单元测试用例。
- 风险点：

菜单的 permissionCode 必须与 route.meta.permissionCode 一致，否则菜单与路由无法关联（回显/跳转会失败）。
若后端返回不包含菜单 permissionCode 的项，getMenuTree 会不能为其填充 path/routeName，导致点击或回显问题；建议菜单管理侧保证菜单与路由权限码一致。
resolveMenuPath 对目录/首子项路径的选择逻辑为“深度优先”，请确认是否与产品预期一致（也可改为“优先第一个子元素”或显式在菜单配置中提供 path）。

- 建议的验收测试：

登录后主导航（顶部）显示正确，点击切换能跳到第一个可用子路径。
在包含隐藏菜单并设置了 parentMenuCode 的情况下：访问隐藏路由，顶部导航/面包屑仍能正确回显（挂载到 parent）。
直接刷新深链页面（未先访问主页）能成功加载对应页面且顶部/侧栏及面包屑回显正确。
没有权限的路由不会被注册/访问（addDynamicRoutes + filterAccessRoutes 生效）。
检查 menuCache 中映射（例如 getAllPermissionCodes() 返回的权限集合）是否完整。